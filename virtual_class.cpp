/*
virtual keywords in modern C++—they’re central 
to polymorphism and object-oriented design.

The virtual keyword marks a member function in a base class as one that 
can be overridden in derived classes. It enables runtime polymorphism: 
the correct function is chosen based on the actual object type, not the pointer/reference type.
*/


#include <iostream>
using namespace std;

class Base {
public:
    virtual void speak() { cout << "Base speaking\n"; }
};

class Derived : public Base {
public:
    void speak() override { cout << "Derived speaking\n"; }
};

int main() {
    Base* b = new Derived();
	/*
	Without virtual, this would print 
    "Base speaking" because the call would be resolved at compile time.
	*/
    b->speak(); // Prints "Derived speaking"
}
/*
Modern C++ Enhancements

override (C++11)
    Ensures a derived function actually overrides a base virtual function.
    Prevents subtle bugs from mismatched signatures.
*/

class Derived : public Base {
public:
    void speak() override; // compiler checks correctness
};
/*
    Prevents further overriding of a virtual function.
    Can also be applied to classes to prevent inheritance.
*/
class Derived : public Base {
public:
    void speak() final; // no further overrides allowed
};
/*
 = 0 (Pure Virtual Functions)
    Declares a function as abstract, making the class an abstract base class.
*/
class Interface {
public:
    virtual void run() = 0; // must be implemented in derived class
};
/*
Virtual Destructors
Always mark destructors virtual in polymorphic base classes to ensure proper cleanup.
*/
class Base {
public:
    virtual ~Base() {}
};
/*
Best Practices in Modern C++

Use override consistently—it’s a safety net.
Use final when you want to lock down behavior.
Always declare a virtual destructor in base classes meant for polymorphism.
Prefer interfaces (pure virtual classes) for clean abstraction.
Avoid excessive virtual use in performance-critical paths—consider
alternatives like CRTP (Curiously Recurring Template Pattern).
*/

#include <iostream>
using namespace std;

class Animal {
public:
    virtual void sound() = 0;       // pure virtual
    virtual ~Animal() = default;    // virtual destructor
};

class Dog : public Animal {
public:
    void sound() override { cout << "Woof!\n"; }
};

class GuardDog : public Dog {
public:
    void sound() final override { cout << "Loud Woof!\n"; }
};

int main() {
    Animal* a = new GuardDog();
    a->sound(); // "Loud Woof!"
    delete a;   // safe cleanup
}
/*
Virtual Mechanism Internals
Virtual Table (vtable)
Each polymorphic class (a class with at least one virtual function) has a hidden vtable generated by the compiler.
The vtable is essentially an array of function pointers.
Each entry corresponds to a virtual function in the class.
At runtime, when you call a virtual function through a pointer/reference, the program looks up the correct function in the vtable.

Example:
*/
class Base {
public:
    virtual void foo();
    virtual void bar();
};

class Derived : public Base {
public:
    void foo() override; // replaces Base::foo in vtable
};
/*
Virtual Pointer (vptr)
    Each object of a polymorphic class contains a hidden vptr (virtual pointer).
    The vptr points to the vtable of the actual type of the object.
    When you construct a Derived, its constructor sets the vptr to point to Derived’s vtable.
    This is why calling foo() on a Base* that actually points to a Derived object invokes Derived::foo.
Modern Specifiers
    Override:
    Ensures the derived function matches a base virtual function signature.
    Prevents silent bugs where you think you’re overriding but actually just hiding.
*/

class Derived : public Base {
    void foo(int) override; // ERROR if Base::foo has no int parameter
};
/*
final
Prevents further overriding of a virtual function.
Can also be applied to a class to prevent inheritance.
*/

class Derived : public Base {
    void bar() final; // cannot be overridden further
};

class FinalClass final : public Base {}; // cannot be subclassed
/* More:
Pure Virtual Functions
    Declared with = 0.
    They reserve a slot in the vtable but don’t provide an implementation.
    Derived classes must fill that slot.
2. Virtual Destructors
    Ensures the correct destructor is called when deleting through a base pointer.
    Without it, only the base destructor runs, potentially leaking resources.
3. Multiple Inheritance
    Each base with virtual functions contributes its own vtable.
    The derived object may contain multiple vptrs.
    This is why multiple inheritance can complicate object layout.
*/



class Sensor {
public:
    virtual void read() = 0;          // pure virtual
    virtual ~Sensor() = default;      // virtual destructor
};

class Camera : public Sensor {
public:
    void read() override { cout << "Camera reading\n"; }
};

class ThermalCamera : public Camera {
public:
    void read() final override { cout << "Thermal camera reading\n"; }
};

int main() {
    Sensor* s = new ThermalCamera();
    s->read();   // vtable dispatch → ThermalCamera::read
    delete s;    // virtual destructor ensures proper cleanup
}
/*
The Diamond Problem
Imagine a class hierarchy shaped like a diamond:
*/  

class A {
public:
    void hello() { std::cout << "Hello from A\n"; }
};

class B : public A {};
class C : public A {};
class D : public B, public C {};
/*
The Problem
Ambiguity: If you call d.hello(), 
the compiler doesn’t know whether to use the A from B or the A from C.
Memory duplication: D contains two separate A subobjects, wasting space 
and potentially causing inconsistent state.
	
The Fix
By declaring inheritance as virtual, you tell the compiler that only 
one shared base subobject should exist, even if multiple paths lead to it.
*/

class A {
public:
    void hello() { std::cout << "Hello from A\n"; }
};

class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};
/*
How It Works Internally
With virtual inheritance, the compiler arranges the object layout 
so that the most derived class (D) controls the construction of A.
B and C no longer construct their own A subobjects.
Instead, D ensures a single A instance is created and shared.	
Example:
*/

#include <iostream>
using namespace std;

class Device {
public:
    virtual void info() { cout << "Generic Device\n"; }
};

class Camera : virtual public Device {
public:
    void info() override { cout << "Camera Device\n"; }
};

class Sensor : virtual public Device {
public:
    void info() override { cout << "Sensor Device\n"; }
};

class SmartCam : public Camera, public Sensor {
public:
    void info() override { cout << "SmartCam Device\n"; }
};

int main() {
    SmartCam sc;
    sc.info(); // "SmartCam Device"
}



